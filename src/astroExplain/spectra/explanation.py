"""Functionality to handle explanation objects from LimeSpetraExplainer"""
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import numpy as np

from lime.lime_image import ImageExplanation

#########################################################################
class TellMeWhy:
    #####################################################################
    """
    Class to illustrate lime_image explanations of anomalous spectra
    where a spectrum is took as a (1, number_of_fluxes) gray image
    and the superpixel are collections of pixels
    """
    #####################################################################
    def __init__(self, explanation: ImageExplanation, wave: np.array):
        """
        INPUT
        explanation: an explanation generated by lime_image explainer.
        wave: array with the wavelengts associated to the spectrum
        """

        self.galaxy = explanation.image[0, :, 0]
        self.segments = explanation.segments[0, :]
        self.wave = wave

        self.explanation = explanation

    def spectrum_in_segments(self):
        """
        Return array where each row contains fluxes values per
        segment. Row zero contains only the fluxes of segment
        zero and the rest of the fluxes are set to zero and
        so on

        OUTPUT

        fluxes_per_segment: array where each row contains
        fluxes of segment with the same row index and nans
        for the rest of fluxes

        """

        number_segments = np.unique(self.segments).size
        number_fluxes = self.galaxy.size

        fluxes_per_segment = np.empty((number_segments, number_fluxes))

        print(fluxes_per_segment.shape)

        # substract 1 to match id to start at zero
        for segment_id in np.unique(self.segments - 1):
            # print(segment_id)
            flux = np.where(self.segments == segment_id, self.galaxy, np.nan)
            fluxes_per_segment[segment_id, :] = flux

        return fluxes_per_segment

    @staticmethod
    def plot_full_explanation(figure_size: tuple = (10, 5)) -> tuple:
        """
        Builds skeleton to plot the spectrum and the normalized
        explanation weights pixel by pixel in two subplots

        INPUT
        figure_size: tuple with the size of the figure

        OUTPUT
        (fig, axs): of the explanation
            axs: 2-rows and 1-column
        """
        #################################################################
        fig, axs = plt.subplots(
            nrows=2, ncols=1, sharex=True, figsize=figure_size
        )

        return fig, axs

    #####################################################################
    def smooth_and_normalize_explanation(
        self, median_smooth: bool = False, drop_fraction: float = 0.1
    ) -> np.array:
        """
        Takes vectorized array with explanation weights and smooths it
        to dilute contamination due to noise in spectra

        INPUT
        median_smooth: If True it substracts the median to the
            array with explanation weights
        drop_fraction: indicates the width of the band to ignore
            segments with explanation weights inside of this band.
            For instance, if it is 0.1, then weights with absolute
            values smaller to 0.1*np.abs(weights).max() would be
            ignore
        OUTPUT
        heatmap: array with median & drop_fraction smoothing +
            normalization
        """

        heatmap = self.get_heatmap()

        # smooth noise
        if median_smooth is True:
            absolute_heatmap = np.abs(heatmap)
            sign_heatmap = np.sign(heatmap)
            heatmap = absolute_heatmap - np.median(absolute_heatmap)
            heatmap *= sign_heatmap

        # normalize heatmap
        heatmap *= 1 / np.abs(heatmap).max()
        # smooth noise with drop_fraction
        heatmap = np.where(np.abs(heatmap) < drop_fraction, 0, heatmap)

        return heatmap

    ###########################################################################
    def positive_mask_and_segments(self, number_of_features: int = 5) -> tuple:
        #######################################################################
        """
        Get mask and segments according to either a positive or
        negative contribution to the anomaly score.
        Segments obtained with this method will be have NaN values
        where there is no contribution and the actual flux where
        there is a contribution to the anomaly score

        INPUT
        number_of_features: example: 6, then it will get the six
            segments with the largest inpat to the anomaly score.
            If None, it will consider all the segments
        OUTPUT
        (spectrum_mask, explanation_segments)
        spectrum_mask: mask highlighting segments that contribute
            to the anomaly score
        explanation_segments: array with flux values at contributing
            segments, and NaNs otherwise
        """
        #######################################################################
        if number_of_features is None:
            # set to the total number of segments
            number_of_features = np.unique(self.segments).size
        #######################################################################
        __, spectrum_mask = self.explanation.get_image_and_mask(
            label=self.explanation.top_labels[0],
            positive_only=True,
            negative_only=False,
            num_features=number_of_features,
            # consider all weights by default
            min_weight=-np.inf,
        )
        #######################################################################
        # ignore values that do not contribute to the score
        explanation_segments = np.where(
            spectrum_mask[0, :] == 0, np.nan, self.galaxy
        )

        return spectrum_mask, explanation_segments

    ###########################################################################
    def negative_mask_and_segments(self, number_of_features: int = 5) -> tuple:
        #######################################################################
        """
        Get mask and segments according to either a positive or
        negative contribution to the anomaly score.
        Segments obtained with this method will be have NaN values
        where there is no contribution and the actual flux where
        there is a contribution to the anomaly score

        INPUT
        number_of_features: example: 6, then it will get the six
            segments with the largest inpat to the anomaly score.
            If None, it will consider all the segments
        OUTPUT
        (spectrum_mask, explanation_segments)
        spectrum_mask: mask highlighting segments that contribute
            to the anomaly score
        explanation_segments: array with flux values at contributing
            segments, and NaNs otherwise
        """
        #######################################################################
        if number_of_features is None:
            # set to the total number of segments
            number_of_features = np.unique(self.segments).size
        #######################################################################
        __, spectrum_mask = self.explanation.get_image_and_mask(
            label=self.explanation.top_labels[0],
            positive_only=False,
            negative_only=True,
            num_features=number_of_features,
            # consider all weights by default
            min_weight=-np.inf,
        )
        #######################################################################
        # ignore values that do not contribute to the score
        explanation_segments = np.where(
            spectrum_mask[0, :] == 0, np.nan, self.galaxy
        )

        return spectrum_mask, explanation_segments

    ###########################################################################
    def plot_heatmap_spectrum(
        self, heatmap: np.array, symmetric_map: bool
    ) -> tuple:

        """
        Create a set of line segments so that we can color them
        individually. This creates the points as a N x 1 x 2 array
        so that we can stack points together easily to get the
        segments. The segments array for line collection
        needs to be (numlines) x (points per line) x 2 (for x and y)

        INPUT
        heatmap: array with the explanation weights pixel by pixel
        symmetric_map: if True, colorbar will be symmetric

        OUTPUT
        (fig, ax): of the heatmap
        """

        # Get average since line coloring requires the heatmap
        # size to shrink
        heatmap = self.get_heatmap()
        heatmap = 0.5 * (heatmap[:-1] + heatmap[1:])

        points = np.array([self.wave, self.galaxy]).T.reshape((-1, 1, 2))
        segments = np.concatenate([points[:-1], points[1:]], axis=1)

        fig, ax = plt.subplots(figsize=(10, 5))

        # normalize heatmap
        heatmap *= 1 / np.abs(heatmap).max()

        if symmetric_map is True:

            vmin, vmax = -1, 1

        else:
            vmin = heatmap.min()
            vmax = heatmap.max()

        norm = plt.Normalize(vmin, vmax)

        lc = LineCollection(segments, cmap="RdBu", norm=norm)
        lc.set_array(heatmap)
        lc.set_linewidth(1.5)

        line = ax.add_collection(lc)
        fig.colorbar(line, ax=ax)

        ax.set_xlim(self.wave.min() - 10, self.wave.max() + 10)
        ax.set_ylim(self.galaxy.min() - 1, self.galaxy.max() + 2)

        return fig, ax

    ###########################################################################
    def get_heatmap(self) -> np.array:

        """
        Returns array of explanation weights pixel by pixel
        """

        print("Get heat map of explanation", end="\n")

        # there is only one label, since I have a regressor
        ind = self.explanation.top_labels[0]

        # Map each explanation weight to the corresponding superpixel
        dict_heatmap = dict(self.explanation.local_exp[ind])

        heatmap = np.vectorize(dict_heatmap.get)(self.segments)

        return heatmap
