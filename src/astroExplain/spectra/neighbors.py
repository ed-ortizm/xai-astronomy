import copy
from skimage.color import gray2rgb
import numpy as np
###############################################################################
class ImageNeighbors:

    "Generate neighboring spectra as LimeSpectraImageExplainer would"

    def __init__(self,
        image: np.array,
        segmentation_function,
        random_seed: int=None,
    ):

        """
            INPUT
            image: gray or RGB representation of a spectrum
            segmentation_function: segmentation funtion that has as
                input the image. Other parameters must be set via
                partial previously.
            random_seed: if not None, the seed is set
        """

        # check if image is gray or RGB
        right_image_dimension = (image.ndim == 2) or (image.ndim == 3)
        assert right_image_dimension

        self.image = image
        self.segments = segmentation_function(image)

        if random_seed != None:
            np.random.seed(random_seed)
    ###########################################################################
    def get_neighbors(self,
        number_samples: int=50,
        hide_color: float=0.,
        loc=0,
        scale=0.2,
    )-> np.array:
        """
            Get samples aking to those generated by lime. The first
            element of the array is the original image

            INPUT
                number_samples: number of neighbors to sample
                hide_color: value to fill segments that
                    "won't be cosidered" by the predictor.
                    If "mean", it will fill each segment  with the mean
                    value per channel. If "normal", it will pertub pixels
                    in each off superpixelsfrom a Normal distribution
                loc: mean of the normal distribution in case hide color
                    is set to "normal"
                scale: standard deviation of the normal distribution in
                    case hide color is set to "normal"
            OUTPUT
                neighbors: array with sampled neighbors. The first
                    element of the array is the original image
        """

        image_fudged = self.fudge_galaxy(hide_color, loc, scale)

        number_features = np.unique(self.segments).shape[0]

        on_off_batch_super_pixels = np.random.randint(0, 2,
            number_samples * number_features
        ).reshape((number_samples, number_features))

        # first row for the original image
        on_off_batch_super_pixels[0, :] = 1

        neighbors = []

        for on_off_super_pixels in on_off_batch_super_pixels:

            temp = copy.deepcopy(self.image)

            off_super_pixels = np.where(
                on_off_super_pixels == 0
            )[0]

            mask_off_superpixels = np.zeros(self.segments.shape).astype(bool)

            for off in off_super_pixels:
                mask_off_superpixels[self.segments == off] = True

            temp[mask_off_superpixels] = image_fudged[mask_off_superpixels]

            neighbors.append(temp)

        return np.array(neighbors)
    ###########################################################################
    def fudge_galaxy(self, hide_color: float = 0., loc=0, scale=0.2) -> np.array:
        """
            Fudge image of galaxy to set pixel values of segments
            ignored in sampled neighbors

            INPUT
                hide_color: value to fill segments that
                    "won't be cosidered" by the predictor. If None,
                    it will fill each segment  with the mean value
                    per channel
            OUTPUT
                image_fudged: galaxy image with segments to ignore
                    in neighbors set to hide_color
        """

        if hide_color == "mean":

            image_fudged = self.fudge_with_mean()

        elif hide_color == "normal":

            image_fudged = self.fudge_from_normal(loc, scale)

        else:
            image_fudged = hide_color

        return image_fudged
    ###########################################################################
    def fudge_with_mean(self):

        image_fudged = self.image.copy()

        for segment in np.unique(self.segments):

            mask_segments = self.segments == segment

            mean_per_segment_per_channel = np.mean(
                self.image[mask_segments], axis=(0, 1)
            )

            image_fudged[mask_segments] = mean_per_segment_per_channel

        return image_fudged
    ###########################################################################
    def fudge_from_normal(self, loc=0, scale=0.2):

        image_fudged = self.image.copy()

        image_fudged += np.random.normal(loc, scale, size=self.image.shape)

        return image_fudged
###############################################################################
class TabularNeighbors:
    pass

###############################################################################
