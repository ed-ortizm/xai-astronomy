import copy
from skimage.color import gray2rgb
import numpy as np
###############################################################################
class ImageNeighbors:

    "Generate neighboring spectra as LimeSpectraImageExplainer would"

    def __init__(self,
        image: np.array,
        segmentation_function,
        random_seed: int=None,
    ):

        """
            INPUT
            image: gray or RGB representation of a spectrum
            segmentation_function:

        """

        right_image_dimension = (image.ndim == 2) or (image.ndim == 3)
        assert right_image_dimension
        self.image = image
        # add code to make sure it is at least a gray image
        self.segments = segmentation_function(image)

        if random_seed != None:
            np.random.seed(random_seed)
    ###########################################################################
    def get_neighbors(self,
        number_samples: int=50,
        hide_color: float=0.,
        loc=0, scale=0.2,
    )-> np.array:
        """
            Get samples aking to those generated by lime. The first
            element of the array is the original image

            INPUT
                number_samples: number of neighbors to sample
                hide_color: value to fill segments that
                    "won't be cosidered" by the predictor.
                    If None, it will fill each segment  with
                    the mean value per channel
                    If "normal", it will pertub pixels in each
                    off superpixels from a Normal distribution
            OUTPUT
                neighbors: array with sampled neighbors. The first
                    element of the array is the original image
        """

        fudged_galaxy = self.fudge_galaxy(hide_color, loc, scale)

        number_features = np.unique(self.segments).shape[0]

        on_off_batch_super_pixels = np.random.randint(0, 2,
            number_samples * number_features
        ).reshape((number_samples, number_features))

        # first row for the original image
        on_off_batch_super_pixels[0, :] = 1

        neighbors = []

        for on_off_super_pixels in on_off_batch_super_pixels:

            temp = copy.deepcopy(self.image)

            off_super_pixels = np.where(
                on_off_super_pixels == 0
            )[0]

            mask_off_superpixels = np.zeros(self.segments.shape).astype(bool)

            for off in off_super_pixels:
                mask_off_superpixels[self.segments == off] = True

            temp[mask_off_superpixels] = fudged_galaxy[mask_off_superpixels]

            neighbors.append(temp)

        return np.array(neighbors)
    ###########################################################################
    def fudge_galaxy(self, hide_color: float = 0., loc=0, scale=0.2) -> np.array:
        """
            Fudge image of galaxy to set pixel values of segments
            ignored in sampled neighbors

            INPUT
                hide_color: value to fill segments that
                    "won't be cosidered" by the predictor. If None,
                    it will fill each segment  with the mean value
                    per channel
            OUTPUT
                fudged_galaxy: galaxy image with segments to ignore
                    in neighbors set to hide_color
        """

        if hide_color == "mean":

            fudged_galaxy = self.fudge_with_mean()

        elif hide_color == "normal":

            fudged_galaxy = self.fudge_from_normal(loc, scale)

        else:
            fudged_galaxy = np.ones(shape=self.image.shape)

        return fudged_galaxy
    ###########################################################################
    def fudge_with_mean(self):

        fudged_galaxy = self.image.copy()

        for segment in np.unique(self.segments):

            mask_segments = self.segments == segment

            mean_per_segment_per_channel = np.mean(
                self.image[mask_segments], axis=(0, 1)
            )

            fudged_galaxy[mask_segments] = mean_per_segment_per_channel

        return fudged_galaxy
    ###########################################################################
    def fudge_from_normal(self, loc=0, scale=0.2):

        fudged_galaxy = self.image.copy()

        fudged_galaxy += np.random.normal(loc, scale, size=self.image.shape)

        return fudged_galaxy
###############################################################################
class TabularNeighbors:
    pass

###############################################################################
