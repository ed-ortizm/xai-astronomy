class ImageNeighbors:

    "Generate neighboring spectra as LimeSpectraImageExplainer would"

    def __init__(self,
        image: np.array,
        segmentation_function,
    ):

        """
            INPUT
            image:
            segmentation_function:

        """

        self.image = image

        self.segments = segmentation_function(image)

        if random_seed != None:
            np.random.seed(random_seed)
    ###########################################################################
    def get_neighbors(self,
        number_samples: int=50,
        hide_color: float=0.,
        loc=0, scale=0.2,
    )-> np.array:
        """
            Get samples aking to those generated by lime. The first
            element of the array is the original image

            INPUT
                number_samples: number of neighbors to sample
                hide_color: value to fill segments that
                    "won't be cosidered" by the predictor.
                    If None, it will fill each segment  with
                    the mean value per channel
                    If "normal", it will pertub pixels in each
                    off superpixels from a Normal distribution
            OUTPUT
                neighbors: array with sampled neighbors. The first
                    element of the array is the original image
        """

        fudged_galaxy = self.fudge_galaxy(hide_color, loc, scale)

        number_features = np.unique(self.segments).shape[0]

        on_off_batch_super_pixels = np.random.randint(0, 2,
            number_samples * number_features
        ).reshape((number_samples, number_features))

        # first row for the original image
        on_off_batch_super_pixels[0, :] = 1

        neighbors = []

        for on_off_super_pixels in on_off_batch_super_pixels:

            temp = copy.deepcopy(self.image)

            off_super_pixels = np.where(
                on_off_super_pixels == 0
            )[0]

            mask = np.zeros(self.segments.shape).astype(bool)

            for off in off_super_pixels:
                mask[self.segments == off] = True

            temp[mask] = fudged_galaxy[mask]

            neighbors.append(temp)

        return np.array(neighbors)
    ###########################################################################
    def fudge_galaxy(self, hide_color: float = 0., loc=0, scale=0.2) -> np.array:
        """
            Fudge image of galaxy to set pixel values of segments
            ignored in sampled neighbors

            INPUT
                hide_color: value to fill segments that
                    "won't be cosidered" by the predictor. If None,
                    it will fill each segment  with the mean value
                    per channel
            OUTPUT
                fudged_galaxy: galaxy image with segments to ignore
                    in neighbors set to hide_color
        """

        if hide_color == "mean":

            fudged_galaxy = self.fudge_with_mean()

        elif hide_color == "normal"

            fudged_galaxy = self.fudge_from_normal(scale, loc)

        else:
            fudged_galaxy[:] = hide_color

        return fudged_galaxy
    ###########################################################################
    def fudge_with_mean(self):

        fudged_galaxy = self.image.copy()

        for segment in np.unique(self.segments):

            mask_segments = self.segments == segment

            mean_per_segment_per_channel = np.mean(
                self.image[mask_segments], axis=(0, 1)
            )

            fudged_galaxy[mask_segments] = mean_per_segment_per_channel

        return fudged_galaxy
    ###########################################################################
    def fudge_from_normal(self, loc=0, scale=0.2):

        fudged_galaxy = self.image.copy()

        fudged_galaxy += np.random.normal(loc, scale, size=self.image.shape)

        return fudged_galaxy
###############################################################################
class TabularNeighbors:
    pass

###############################################################################
